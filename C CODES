#stack under over flow 

#include <stdio.h>      #define SIZE 5
int stack[SIZE],        top = -1;
void push(int value) {       if (top == SIZE - 1)
        printf("Stack Overflow\n");     else {
        top++;         stack[top] = value;   }   }
void pop() {      if (top == -1)
        printf("Stack Underflow\n");       else {
        printf("Popped %d\n", stack[top]);
        top--;      }   }
void display() {       if (top == -1)
        printf("Stack is empty\n");
    else {        printf("Stack: ");
        for (int i = top; i >= 0; i--)          printf("%d ", stack[i]);
        printf("\n");   }  }       int main() {
    int choice, value;      while (1) {
        printf("\n1. Push\n2. Pop\n3. Display\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);    switch (choice) {
      case 1:            printf("Enter value to push: ");        scanf("%d", &value);       push(value);       break;
     case 2:       pop();       break;
    case 3:               display();                break;   
case 4:     return 0;            default:
                printf("Invalid choice\n");  }  }  }



#Parenthesis Matching using Stacks

#include <stdio.h>     #include <string.h>      #define SIZE 100
char stack[SIZE];     int top = -1;
void push(char value) {         stack[++top] = value;  } 
char pop() {
    return stack[top--];  } 
int isMatchingPair(char left, char right) {
    return (left == '(' && right == ')') ||
           (left == '{' && right == '}') ||
           (left == '[' && right == ']');  } 
int checkBalancedParentheses(char exp[]) {
    for (int i = 0; i < strlen(exp); i++) {
        if (exp[i] == '(' || exp[i] == '{' || exp[i] == '[')
            push(exp[i]);
        else if (exp[i] == ')' || exp[i] == '}' || exp[i] == ']') {
            if (top == -1 || !isMatchingPair(pop(), exp[i]))
                return 0; } }
    return (top == -1); }
int main() {      char exp[SIZE];
    printf("Enter an expression: ");       scanf("%s", exp);
    if (checkBalancedParentheses(exp))          printf("Balanced\n");
    else    printf("Not Balanced\n");
    return 0; } 



# infix to postfix 

#include <stdio.h>     #include <ctype.h>
char stack[100];     int top = -1;
void push(char x) {        stack[++top] = x; }
char pop() {      return stack[top--]; }
int precedence(char x) {         if (x == '(')
        return 0;       if (x == '+' || x == '-')
        return 1;        if (x == '*' || x == '/')
        return 2;       return 0; }
void infixToPostfix(char* exp) {      char* e, x;
    e = exp;      while (*e != '\0') {        if (isalnum(*e))
            printf("%c", *e);
        else if (*e == '(')            push(*e);
        else if (*e == ')') {            while ((x = pop()) != '(')
                printf("%c", x);
        } else {     while (precedence(stack[top]) >= precedence(*e))                printf("%c", pop());
            push(*e); }      e++; }   while (top != -1) {
        printf("%c", pop()); }  printf("\n"); } 
int main() {    char exp[100];
    printf("Enter the infix expression: ");    scanf("%s", exp);
    printf("Postfix Expression: ");    infixToPostfix(exp);
    return 0; }


# Postfix Expression Evaluation 

#include <stdio.h>     #include <ctype.h>        int stack[100];
int top = -1;      void push(int x) {
    stack[++top] = x; }       int pop() {
    return stack[top--]; }
int evaluatePostfix(char* exp) {    char* e;
    int n1, n2, n3, num;   e = exp;
    while (*e != '\0') {
        if (isdigit(*e)) {        num = *e - '0';
            push(num);      } else {
            n1 = pop();        n2 = pop();     switch (*e) {
         case '+':   n3 = n2 + n1;          break;           case '-':  n3 = n2 - n1;         break;
                case '*':  n3 = n2 * n1;
                    break;            case '/':  n3 = n2 / n1;       break; } 
      push(n3); }     e++; }      return pop(); } 
int main() {
    char exp[100];
    printf("Enter the postfix expression: ");
    scanf("%s", exp);
    printf("Result: %d\n", evaluatePostfix(exp));
    return 0; } 



#Linear Queue under over flow 


#include <stdio.h>
#define SIZE 5
int queue[SIZE], front = -1, rear = -1;
void enqueue(int value) {
    if (rear == SIZE - 1)        printf("Queue Overflow\n");
    else {        if (front == -1) front = 0;         rear++;
        queue[rear] = value;  }  }     void dequeue() {
    if (front == -1 || front > rear)
        printf("Queue Underflow\n");
    else {        printf("Dequeued %d\n", queue[front]);       front++; } } 
void display() {
    if (front == -1 || front > rear)
        printf("Queue is empty\n");
    else {        printf("Queue: ");        for (int i = front; i <= rear; i++)  
printf("%d ", queue[i]);      printf("\n"); }   } 
int main() {      int choice, value;    while (1) {
        printf("\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);         switch (choice) {
            case 1:    printf("Enter value to enqueue: ");
                scanf("%d", &value);     enqueue(value);      break;
            case 2: dequeue();   break;
            case 3: display();  break;
            case 4:  return 0;  default:
                printf("Invalid choice\n"); }  }   }



# Circular Queue (over under flow )

#include <stdio.h>
#define SIZE 5
int queue[SIZE], front = -1, rear = -1;
void enqueue(int value) {
    if ((front == 0 && rear == SIZE - 1) || (rear == (front - 1) % (SIZE - 1))) {
        printf("Queue Overflow\n");       } else {
        if (front == -1) {           front = rear = 0;
        } else if (rear == SIZE - 1 && front != 0) {
            rear = 0;        } else {
            rear++; }           queue[rear] = value;  }   } 
void dequeue() {
    if (front == -1) {
        printf("Queue Underflow\n");    } else {
        printf("Dequeued %d\n", queue[front]);
        if (front == rear) {            front = rear = -1;
        } else if (front == SIZE - 1) {           front = 0;
        } else {           front++;  }   }  }     void display() {
    if (front == -1) {       printf("Queue is empty\n");     } else {
        printf("Queue: ");       if (rear >= front) {
            for (int i = front; i <= rear; i++) {
                printf("%d ", queue[i]);  }         } else {
       for (int i = front; i < SIZE; i++) {         printf("%d ", queue[i]);  }      for (int i = 0; i <= rear; i++) {                printf("%d ", queue[i]);  }   }   
        printf("\n");  }   }
int main() {     int choice, value;
    while (1) {
        printf("\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);        switch (choice) {
    case 1:  printf("Enter value to enqueue: ");        scanf("%d", &value);       enqueue(value);   break;
            case 2:      dequeue();    break;
            case 3:  display();  break;
            case 4:     return 0;  default:
                printf("Invalid choice\n"); }   }   }


#Priority Queue (int & del )

#include <stdio.h>
#define SIZE 5
int queue[SIZE], rear = -1;
void enqueue(int value) {
    if (rear == SIZE - 1) {
        printf("Queue Overflow\n");
    } else {     int i;
        for (i = rear; i >= 0 && queue[i] > value; i--) {
            queue[i + 1] = queue[i];     }
        queue[i + 1] = value;
        rear++;      }     }     void dequeue() {
    if (rear == -1) {
        printf("Queue Underflow\n");      } else {
        printf("Dequeued %d\n", queue[0]);
        for (int i = 0; i < rear; i++) {
            queue[i] = queue[i + 1];
        }     rear--;   }   }     void display() {
    if (rear == -1) {       printf("Queue is empty\n");
    } else {     printf("Queue: ");
        for (int i = 0; i <= rear; i++) {
            printf("%d ", queue[i]);        }  printf("\n");  }   }
int main() {      int choice, value;       while (1) {
        printf("\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        switch (choice) {
            case 1:
                printf("Enter value to enqueue: ");
                scanf("%d", &value);      enqueue(value);    break;
            case 2:     dequeue();     break;
            case 3:       display();    break;
            case 4:      return 0;     default:
                printf("Invalid choice\n"); }   }  }  



#SLL  (ins beg  del end )

#include <stdio.h>      #include <stdlib.h>
struct Node {      int data;       struct Node* next;     };
struct Node* head = NULL;   
void insertAtBeginning(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;    newNode->next = head;    head = newNode;  }    
void deleteFromEnd() {
    if (head == NULL) {        printf("List is empty\n");
    } else if (head->next == NULL) {
        printf("Deleted %d\n", head->data);        free(head);        head = NULL;
    } else {      struct Node* temp = head;
        while (temp->next->next != NULL) {            temp = temp->next;   }   
        printf("Deleted %d\n", temp->next->data);      free(temp->next);
        temp->next = NULL;     }   }
void display()          {      if (head == NULL) {
        printf("List is empty\n");       } else {
        struct Node* temp = head;
        printf("Linked List: ");     while (temp != NULL) {
            printf("%d ", temp->data);
            temp = temp->next; }  
        printf("\n"); }    }     int main() {
    int choice, value;      while (1) {
        printf("\n1. Insert at Beginning\n2. Delete from End\n3. Display\n4. Exit\n");
        printf("Enter your choice: ");     scanf("%d", &choice);        switch (choice) {
            case 1:     printf("Enter value to insert: ");
                scanf("%d", &value);
                insertAtBeginning(value);    break;
            case 2:      deleteFromEnd();     break;
            case 3:        display();    break;
            case 4:       return 0;      default:
                printf("Invalid choice\n"); }   }   }  




#SLL  ins end &  del beg   

#include <stdio.h>      #include <stdlib.h>
struct Node     {      int data;       struct Node* next;   };
struct Node* head = NULL;
void insertAtEnd(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;     newNode->next = NULL;
    if (head == NULL) {    head = newNode;
    } else {
        struct Node* temp = head;
        while (temp->next != NULL) {      temp = temp->next;      }
        temp->next = newNode; }   }   
void deleteFromBeginning() {
    if (head == NULL) {
        printf("List is empty\n");
    } else {       struct Node* temp = head;
        printf("Deleted %d\n", head->data);
        head = head->next;
        free(temp);   }   }  
void display() {      if (head == NULL) {       printf("List is empty\n");
    } else {     struct Node* temp = head;
        printf("Linked List: ");   while (temp != NULL) {
            printf("%d ", temp->data);      temp = temp->next;
        }   printf("\n");  }   }   
int main() {       int choice, value;      while (1) {
        printf("\n1. Insert at End\n2. Delete from Beginning\n3. Display\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);        switch (choice) {
            case 1:  printf("Enter value to insert: ");      scanf("%d", &value);
                insertAtEnd(value);             break;
            case 2:       deleteFromBeginning();    break;
            case 3:         display();      break;
            case 4:      return 0;       default:
                printf("Invalid choice\n"); }    }   }   



#SLL   int beg & del spe 

#include <stdio.h>      #include <stdlib.h>
 struct Node {    int data;      struct Node* next;
};     struct Node* head = NULL;
void insertAtBeginning(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;    newNode->next = head;   head = newNode;
}    void deleteAtSpecificNode(int key) {
    struct Node* temp = head;       struct Node* prev = NULL;
    if (temp != NULL && temp->data == key) {       head = temp->next;
        free(temp);       printf("Node with value %d deleted\n", key);
        return;  }
    while (temp != NULL && temp->data != key) {
        prev = temp;     temp = temp->next;
    }  if (temp == NULL) {    printf("Node with value %d not found\n", key);      return;  }
    prev->next = temp->next;  free(temp);
    printf("Node with value %d deleted\n", key);
}    void display() {   if (head == NULL
{     printf("List is empty\n");     } else {
    struct Node* temp = head;
    printf("Linked List: ");     while (temp != NULL) {
        printf("%d ", temp->data);     temp = temp->next; }
    printf("\n");  }   }   
int main() {  int choice, value, key;     while (1) {
        printf("\n1. Insert at Beginning\n2. Delete Specific Node\n3. Display\n4. Exit\n");
        printf("Enter your choice: ");       scanf("%d", &choice);      switch (choice) {
            case 1:     printf("Enter value to insert: ");
                scanf("%d", &value);       insertAtBeginning(value);     break;
case 2:      printf("Enter value of the node to delete: ");      scanf("%d", &key);
                deleteAtSpecificNode(key);     break;
            case 3:      display();    break;
            case 4:      return 0;
            default:         printf("Invalid choice\n"); }    }    }   



#stack SLL 

#include <stdio.h>  #include <stdlib.h>
struct Node {    int data;   struct Node* next;
};    struct Node* top = NULL;    void push(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;    newNode->next = top;    top = newNode;
    printf("%d pushed to stack\n", value);
}    void pop() {    if (top == NULL) {   
printf("Stack Underflow\n");      } else {
        struct Node* temp = top;        printf("Popped %d\n", top->data);
        top = top->next;       free(temp); }    }   
void display() {      if (top == NULL) {
        printf("Stack is empty\n");     } else {
        struct Node* temp = top;
        printf("Stack: ");      while (temp != NULL) {
            printf("%d ", temp->data);         temp = temp->next;
        }    printf("\n");   }   }  
int main() {     int choice, value;     while (1) {
        printf("\n1. Push\n2. Pop\n3. Display\n4. Exit\n");      printf("Enter your choice: ");
        scanf("%d", &choice);      switch (choice) {
            case 1:     printf("Enter value to push: ");    scanf("%d", &value);      push(value);          break;
            case 2:       pop();         break;
            case 3:      display();         break;
            case 4:        return 0;     default:       printf("Invalid choice\n");  }   }   }  


#linear Q SLL 

#include <stdio.h>     #include <stdlib.h>
struct Node {    int data;    struct Node* next;     };
struct Node* front = NULL;struct Node* rear = NULL;
void enqueue(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));        newNode->data = value;
    newNode->next = NULL;   if (front == NULL && rear == NULL) {     front = rear = newNode;
    } else {     rear->next = newNode;      rear = newNode;
    }     printf("%d enqueued\n", value);     }
void dequeue() {    if (front == NULL) {     printf("Queue Underflow\n");
    } else {      struct Node* temp = front;     printf("Dequeued %d\n", front->data);
        front = front->next;       free(temp);     if (front == NULL) {        rear = NULL; }  }  }
void display() {    if (front == NULL) {     printf("Queue is empty\n");
    } else {        struct Node* temp = front;       printf("Queue: ");
        while (temp != NULL) {        printf("%d ", temp->data);        temp = temp->next;
        }     printf("\n");  }   }   
int main() {     int choice, value;  while (1) {
        printf("\n1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);      switch (choice) {
            case 1:       printf("Enter value to enqueue: ");
                scanf("%d", &value);            enqueue(value);             break;
            case 2:                dequeue();              break;
            case 3:             display();                break;
            case 4:             return 0;          default:
                printf("Invalid choice\n");        }  }   }


# CLL ins beg  del end 

#include <stdio.h>      #include <stdlib.h>
struct Node {    int data;     struct Node* next;      }; 
struct Node* last = NULL;      void insertAtBeginning(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
   newNode->data = value;
    if (last == NULL) {      newNode->next = newNode;      last = newNode;
    } else {     newNode->next = last->next;
        last->next = newNode;  }
    printf("%d inserted at the beginning\n", value);  }   
void deleteFromEnd() {   if (last == NULL) {     printf("List is empty\n");
    } else if (last->next == last) {
        printf("Deleted %d\n", last->data);
        free(last);      last = NULL;     } else {
        struct Node* temp = last->next;     while (temp->next != last) {     temp = temp->next;   }
      printf("Deleted %d\n", last->data);       temp->next = last->next;
        free(last);      last = temp;   }    }
void display() {    if (last == NULL) {       printf("List is empty\n");
    } else {       struct Node* temp = last->next;        printf("Circular Linked List: ");
        do {          printf("%d ", temp->data);           temp = temp->next;
        } while (temp != last->next);
        printf("\n");     }      }
int main() {     int choice, value;
    while (1) {         printf("\n1. Insert at Beginning\n2. Delete from End\n3. Display\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);       switch (choice) {
        case 1:      printf("Enter value to insert: ");
          scanf("%d", &value);            insertAtBeginning(value);         break;
            case 2:          deleteFromEnd();           break;
            case 3:          display();         break;
            case 4:       return 0;        default:
                printf("Invalid choice\n");  }   }   }  
